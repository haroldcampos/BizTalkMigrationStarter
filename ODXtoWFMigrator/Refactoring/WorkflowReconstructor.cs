// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using BizTalktoLogicApps.ODXtoWFMigrator;

namespace BizTalktoLogicApps.ODXtoWFMigrator.Refactoring
{
    /// <summary>
    /// Reconstructs workflows by applying pattern-based transformations.
    /// </summary>
    /// <remarks>
    /// This component operates on the LogicAppWorkflowMap generated by the existing mapper,
    /// transforming it to apply detected integration patterns and best practices.
    /// Phase 2 implementation - applies optimizations for 3 high-priority patterns:
    /// 1. Sequential Convoy ? Service Bus/RabbitMQ/Kafka sessions
    /// 2. Scatter-Gather ? Native parallel branches with automatic join
    /// 3. Content-Based Router ? Simplified Switch action
    /// </remarks>
    internal static class WorkflowReconstructor
    {
        /// <summary>
        /// Optimizes a baseline workflow by applying pattern-based transformations.
        /// </summary>
        /// <param name="baseline">The baseline workflow from LogicAppsMapper.</param>
        /// <param name="patterns">Detected integration patterns.</param>
        /// <param name="options">Refactoring options.</param>
        /// <returns>Optimized workflow map.</returns>
        public static LogicAppWorkflowMap OptimizeWorkflow(
            LogicAppWorkflowMap baseline,
            List<OrchestrationReportGenerator.IntegrationPattern> patterns,
            RefactoringOptions options)
        {
            if (baseline == null)
            {
                throw new ArgumentNullException(nameof(baseline));
            }

            if (options == null)
            {
                throw new ArgumentNullException(nameof(options));
            }

            if (patterns == null || patterns.Count == 0)
            {
                return baseline;
            }

            // Deep clone the baseline to avoid modifying the original
            var optimized = CloneWorkflow(baseline);

            // Apply pattern-specific transformations
            foreach (var pattern in patterns)
            {
                switch (pattern.PatternName)
                {
                    case "Sequential Convoy":
                        if (options.SimplifyConvoyPatterns)
                        {
                            ApplyConvoyOptimization(optimized, pattern, options);
                        }
                        break;

                    case "Scatter-Gather":
                        if (options.UseNativeParallelBranches)
                        {
                            ApplyScatterGatherOptimization(optimized, pattern, options);
                        }
                        break;

                    case "Content-Based Router":
                        ApplyContentBasedRouterOptimization(optimized, pattern, options);
                        break;

                    default:
                        break;
                }
            }

            // Apply general optimizations based on strategy
            if (options.ConsolidateNestedScopes)
            {
                ConsolidateNestedScopes(optimized);
            }

            return optimized;
        }

        /// <summary>
        /// Deep clones a LogicAppWorkflowMap to avoid modifying the original.
        /// </summary>
        private static LogicAppWorkflowMap CloneWorkflow(LogicAppWorkflowMap source)
        {
            var cloned = new LogicAppWorkflowMap { Name = source.Name };

            // Clone triggers
            foreach (var trigger in source.Triggers)
            {
                cloned.Triggers.Add(CloneTrigger(trigger));
            }

            // Clone actions
            foreach (var action in source.Actions)
            {
                cloned.Actions.Add(CloneAction(action));
            }

            // Clone variable names
            foreach (var varName in source.VariableNames)
            {
                cloned.VariableNames.Add(varName);
            }

            return cloned;
        }

        /// <summary>
        /// Clones a LogicAppTrigger.
        /// </summary>
        private static LogicAppTrigger CloneTrigger(LogicAppTrigger source)
        {
            return new LogicAppTrigger
            {
                Name = source.Name,
                Kind = source.Kind,
                TransportType = source.TransportType,
                Address = source.Address,
                FolderPath = source.FolderPath,
                FileMask = source.FileMask,
                Sequence = source.Sequence,
                PollingIntervalSeconds = source.PollingIntervalSeconds,
                UserName = source.UserName,
                Password = source.Password,
                ConnectionString = source.ConnectionString,
                PrimaryTransport = source.PrimaryTransport,
                Endpoint = source.Endpoint,
                SecurityMode = source.SecurityMode,
                MessageClientCredentialType = source.MessageClientCredentialType,
                TransportClientCredentialType = source.TransportClientCredentialType,
                MessageEncoding = source.MessageEncoding,
                AlgorithmSuite = source.AlgorithmSuite,
                MaxReceivedMessageSize = source.MaxReceivedMessageSize,
                MaxConcurrentCalls = source.MaxConcurrentCalls,
                OpenTimeout = source.OpenTimeout,
                CloseTimeout = source.CloseTimeout,
                SendTimeout = source.SendTimeout,
                EstablishSecurityContext = source.EstablishSecurityContext,
                NegotiateServiceCredential = source.NegotiateServiceCredential,
                IncludeExceptionDetailInFaults = source.IncludeExceptionDetailInFaults,
                UseSSO = source.UseSSO,
                SuspendMessageOnFailure = source.SuspendMessageOnFailure
            };
        }

        /// <summary>
        /// Recursively clones a LogicAppAction including children and branches.
        /// </summary>
        private static LogicAppAction CloneAction(LogicAppAction source)
        {
            var cloned = new LogicAppAction
            {
                Name = source.Name,
                Type = source.Type,
                Details = source.Details,
                Sequence = source.Sequence,
                IsBranchContainer = source.IsBranchContainer,
                LoopThreshold = source.LoopThreshold,
                ConnectorKind = source.ConnectorKind,
                TargetAddress = source.TargetAddress,
                IsTopic = source.IsTopic,
                HasSubscription = source.HasSubscription,
                QueueOrTopicName = source.QueueOrTopicName,
                SubscriptionName = source.SubscriptionName,
                UserName = source.UserName,
                Password = source.Password,
                ConnectionString = source.ConnectionString,
                SoapAction = source.SoapAction,
                HttpMethod = source.HttpMethod,
                RelativePath = source.RelativePath,
                PrimaryTransport = source.PrimaryTransport,
                Endpoint = source.Endpoint,
                SecurityMode = source.SecurityMode,
                MessageClientCredentialType = source.MessageClientCredentialType,
                TransportClientCredentialType = source.TransportClientCredentialType,
                MessageEncoding = source.MessageEncoding,
                AlgorithmSuite = source.AlgorithmSuite,
                MaxReceivedMessageSize = source.MaxReceivedMessageSize,
                MaxConcurrentCalls = source.MaxConcurrentCalls,
                OpenTimeout = source.OpenTimeout,
                CloseTimeout = source.CloseTimeout,
                SendTimeout = source.SendTimeout,
                EstablishSecurityContext = source.EstablishSecurityContext,
                NegotiateServiceCredential = source.NegotiateServiceCredential,
                TransformClassName = source.TransformClassName
            };

            // Clone message property assignments
            foreach (var kvp in source.MessagePropertyAssignments)
            {
                cloned.MessagePropertyAssignments[kvp.Key] = kvp.Value;
            }

            // Clone children recursively
            foreach (var child in source.Children)
            {
                cloned.Children.Add(CloneAction(child));
            }

            // Clone branches
            foreach (var trueAction in source.TrueBranch)
            {
                cloned.TrueBranch.Add(CloneAction(trueAction));
            }

            foreach (var falseAction in source.FalseBranch)
            {
                cloned.FalseBranch.Add(CloneAction(falseAction));
            }

            return cloned;
        }

        /// <summary>
        /// Applies Sequential Convoy pattern optimization by configuring session-based messaging.
        /// </summary>
        /// <remarks>
        /// For cloud: Uses Service Bus sessions for guaranteed message ordering.
        /// For on-prem: Uses RabbitMQ consumer groups or Kafka partitions.
        /// Removes manual correlation logic from BizTalk as the platform handles it natively.
        /// </remarks>
        private static void ApplyConvoyOptimization(
            LogicAppWorkflowMap workflow,
            OrchestrationReportGenerator.IntegrationPattern pattern,
            RefactoringOptions options)
        {
            var trigger = workflow.Triggers.FirstOrDefault();
            if (trigger == null)
            {
                return;
            }

            // Determine messaging platform based on deployment target
            var messagingPlatform = options.Target == DeploymentTarget.Cloud
                ? options.PreferredMessagingPlatform
                : (options.PreferredMessagingPlatform == "ServiceBus" ? "RabbitMQ" : options.PreferredMessagingPlatform);

            // Update trigger to use session-based messaging
            if (string.Equals(messagingPlatform, "ServiceBus", StringComparison.OrdinalIgnoreCase))
            {
                trigger.Kind = "ServiceBus";
                trigger.TransportType = "ServiceBus";
                trigger.Name = "When_messages_received_in_session";
                
                // Session-enabled connection string
                trigger.ConnectionString = "@appsetting('ServiceBusConnection_Sessions')";
            }
            else if (string.Equals(messagingPlatform, "RabbitMQ", StringComparison.OrdinalIgnoreCase))
            {
                trigger.Kind = "RabbitMQ";
                trigger.TransportType = "RabbitMQ";
                trigger.Name = "When_RabbitMQ_message_received";
                trigger.ConnectionString = "@appsetting('RabbitMQConnection')";
            }
            else if (string.Equals(messagingPlatform, "Kafka", StringComparison.OrdinalIgnoreCase))
            {
                trigger.Kind = "Kafka";
                trigger.TransportType = "Kafka";
                trigger.Name = "When_Kafka_message_received";
                trigger.ConnectionString = "@appsetting('KafkaConnection')";
            }

            // Remove correlation-related actions (platform handles it natively via sessions)
            workflow.Actions.RemoveAll(a =>
                a.Type == "Compose" &&
                (a.Details.IndexOf("correlation", StringComparison.OrdinalIgnoreCase) >= 0 ||
                 a.Name.IndexOf("correlation", StringComparison.OrdinalIgnoreCase) >= 0));
        }

        /// <summary>
        /// Applies Scatter-Gather pattern optimization using native parallel branches.
        /// </summary>
        /// <remarks>
        /// Converts manual parallel sends + correlation receives into Logic Apps parallel branches.
        /// Logic Apps automatically joins all branches (no manual correlation needed).
        /// Adds aggregation step after parallel execution completes.
        /// </remarks>
        private static void ApplyScatterGatherOptimization(
            LogicAppWorkflowMap workflow,
            OrchestrationReportGenerator.IntegrationPattern pattern,
            RefactoringOptions options)
        {
            // Find ParallelContainer actions with SendConnector children
            var parallelActions = workflow.Actions.Where(a =>
                a.Type == "ParallelContainer" &&
                a.Children.Any(c => c.Children.Any(cc => cc.Type == "SendConnector"))).ToList();

            if (!parallelActions.Any())
            {
                return;
            }

            foreach (var parallelAction in parallelActions)
            {
                // Enable concurrency for better performance
                parallelAction.Details = "Parallel branches with automatic join (up to 50 concurrent)";

                // Add comment about optimization
                parallelAction.Name = parallelAction.Name + "_Optimized";

                // Add aggregation action after parallel (if not already present)
                var aggregationExists = workflow.Actions.Any(a =>
                    a.Sequence > parallelAction.Sequence &&
                    (a.Type == "Compose" || a.Type == "Join") &&
                    a.Details.IndexOf("aggregate", StringComparison.OrdinalIgnoreCase) >= 0);

                if (!aggregationExists)
                {
                    var aggregateAction = new LogicAppAction
                    {
                        Name = "Aggregate_Parallel_Results",
                        Type = "Compose",
                        Details = "@body('Parallel_branches')",
                        Sequence = parallelAction.Sequence + 1
                    };

                    workflow.Actions.Insert(workflow.Actions.IndexOf(parallelAction) + 1, aggregateAction);
                }
            }
        }

        /// <summary>
        /// Applies Content-Based Router pattern optimization by simplifying Switch actions.
        /// </summary>
        /// <remarks>
        /// Consolidates nested Decide shapes into a single Switch action.
        /// Simplifies routing expressions for Logic Apps syntax.
        /// Uses dynamic connector selection where appropriate.
        /// </remarks>
        private static void ApplyContentBasedRouterOptimization(
            LogicAppWorkflowMap workflow,
            OrchestrationReportGenerator.IntegrationPattern pattern,
            RefactoringOptions options)
        {
            // Find Switch actions or If actions that can be converted
            var switchActions = workflow.Actions.Where(a => a.Type == "Switch").ToList();
            var nestedIfActions = FindNestedIfActions(workflow.Actions);

            if (!switchActions.Any() && !nestedIfActions.Any())
            {
                return;
            }

            // Optimize existing Switch actions
            foreach (var switchAction in switchActions)
            {
                // Simplify expression if complex
                if (!string.IsNullOrEmpty(switchAction.Details))
                {
                    switchAction.Details = SimplifyRoutingExpression(switchAction.Details);
                }

                switchAction.Name = switchAction.Name + "_Simplified";
            }

            // Convert nested If actions to Switch
            if (nestedIfActions.Any() && options.Strategy != RefactoringStrategy.Conservative)
            {
                foreach (var nestedIf in nestedIfActions)
                {
                    ConvertNestedIfToSwitch(workflow, nestedIf);
                }
            }

        }

        /// <summary>
        /// Finds nested If actions that could be converted to Switch.
        /// </summary>
        private static List<LogicAppAction> FindNestedIfActions(List<LogicAppAction> actions)
        {
            var nested = new List<LogicAppAction>();

            foreach (var action in actions)
            {
                if (action.Type == "If" && 
                    (action.TrueBranch.Any(a => a.Type == "If") || 
                     action.FalseBranch.Any(a => a.Type == "If")))
                {
                    nested.Add(action);
                }

                // Recurse into children
                nested.AddRange(FindNestedIfActions(action.Children));
                nested.AddRange(FindNestedIfActions(action.TrueBranch));
                nested.AddRange(FindNestedIfActions(action.FalseBranch));
            }

            return nested;
        }

        /// <summary>
        /// Converts nested If actions to a cleaner Switch action.
        /// </summary>
        private static void ConvertNestedIfToSwitch(LogicAppWorkflowMap workflow, LogicAppAction nestedIf)
        {
            // Create new Switch action
            var switchAction = new LogicAppAction
            {
                Name = nestedIf.Name.Replace("_If", "_Switch"),
                Type = "Switch",
                Details = SimplifyRoutingExpression(nestedIf.Details),
                Sequence = nestedIf.Sequence
            };

            // Extract cases from nested structure
            var cases = ExtractCasesFromNestedIf(nestedIf);
            foreach (var caseAction in cases)
            {
                switchAction.Children.Add(caseAction);
            }

            // Replace in workflow
            var index = workflow.Actions.IndexOf(nestedIf);
            if (index >= 0)
            {
                workflow.Actions[index] = switchAction;
            }
        }

        /// <summary>
        /// Extracts case actions from nested If structure.
        /// </summary>
        private static List<LogicAppAction> ExtractCasesFromNestedIf(LogicAppAction ifAction)
        {
            var cases = new List<LogicAppAction>();

            // Convert true branch to case
            if (ifAction.TrueBranch.Any())
            {
                var trueCase = new LogicAppAction
                {
                    Name = "Case_True",
                    Type = "Scope",
                    Details = "Condition matched",
                    Sequence = 0,
                    IsBranchContainer = true
                };
                trueCase.Children.AddRange(ifAction.TrueBranch);
                cases.Add(trueCase);
            }

            // Convert false branch to case or extract nested If
            if (ifAction.FalseBranch.Any())
            {
                var falseCase = new LogicAppAction
                {
                    Name = "Case_False",
                    Type = "Scope",
                    Details = "Condition not matched",
                    Sequence = 1,
                    IsBranchContainer = true
                };
                falseCase.Children.AddRange(ifAction.FalseBranch);
                cases.Add(falseCase);
            }

            return cases;
        }

        /// <summary>
        /// Simplifies complex routing expressions for Logic Apps.
        /// </summary>
        private static string SimplifyRoutingExpression(string expression)
        {
            if (string.IsNullOrEmpty(expression))
            {
                return "@triggerBody()?['MessageType']";
            }

            // Remove BizTalk-specific syntax
            var simplified = expression
                .Replace("()", "")
                .Replace("  ", " ")
                .Trim();

            // If it looks like a simple property access, wrap in Logic Apps syntax
            if (!simplified.StartsWith("@") && !simplified.Contains("("))
            {
                simplified = $"@triggerBody()?['{simplified}']";
            }

            return simplified;
        }

        /// <summary>
        /// Consolidates unnecessarily nested Scope actions.
        /// </summary>
        /// <remarks>
        /// Removes single-child Scopes and flattens them into parent.
        /// Preserves Scopes with error handling or multiple children.
        /// </remarks>
        private static void ConsolidateNestedScopes(LogicAppWorkflowMap workflow)
        {
            var scopesRemoved = 0;
            scopesRemoved += ConsolidateScopesRecursive(workflow.Actions);
        }

        /// <summary>
        /// Recursively consolidates scopes in action list.
        /// </summary>
        private static int ConsolidateScopesRecursive(List<LogicAppAction> actions)
        {
            var removedCount = 0;

            for (int i = actions.Count - 1; i >= 0; i--)
            {
                var action = actions[i];

                // Recurse into children first
                removedCount += ConsolidateScopesRecursive(action.Children);
                removedCount += ConsolidateScopesRecursive(action.TrueBranch);
                removedCount += ConsolidateScopesRecursive(action.FalseBranch);

                // Check if this is a single-child scope without error handling
                if (action.Type == "Scope" &&
                    action.Children.Count == 1 &&
                    !action.IsBranchContainer &&
                    action.Details.IndexOf("exception", StringComparison.OrdinalIgnoreCase) < 0 &&
                    action.Details.IndexOf("error", StringComparison.OrdinalIgnoreCase) < 0)
                {
                    // Replace scope with its child
                    var child = action.Children[0];
                    child.Sequence = action.Sequence;
                    actions[i] = child;
                    removedCount++;
                }
            }

            return removedCount;
        }
    }
}
